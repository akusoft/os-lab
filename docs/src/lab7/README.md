# Lab 7：同步互斥

## 同步互斥

## 信号量

## 管程

## 死锁

**死锁**是由于竞争资源或者通信关系，两个或更多线程在执行中出现，永远相互等待只能由其他进程引发的事件。

比如线程 1 正在使用文件 A，同时想要使用文件 B，而文件 B 此时正被线程 2 所使用，线程 2 此时又想使用文件 A，这就造成了死锁。

出现死锁必须同时满足以下 4 个必要条件：

- **互斥**：任何时刻只能有一个进程使用一个资源实例。
- **持有并等待**：进程保持至少一个资源，并正在等待获取其他进程持有的资源。
- **非抢占**：资源只能在进程使用后自愿释放。
- **循环等待**：

死锁的处理方法有：

- **死锁预防**（Deadlock Prevention）：确保系统永远不会进入死锁状态。
- **死锁避免**（Deadlock Avoidance）：在使用前进行判断，只允许不会出现死锁的进程请求资源。
- **死锁检测和恢复**（Deadlock Detection & Recovery）：在检测到运行系统进入死锁状态后，进行恢复。

通常操作系统忽略死锁，由应用进程处理死锁。

**银行家算法**是死锁避免的一种方法。

## 进程通信

**进程通信**（IPC，Inter-Process Communication）是进程进行通信和同步的机制。

IPC 提供 2 个基本操作：

- 发送操作：send(message)
- 接收操作：receive(message)

进程通信流程：

1. 在通信进程间建立通信链路
2. 通过 send/receive 交换消息

进程通信方式有：

- 间接通信：通过操作系统维护的消息队列实现进程间的消息接收和发送
- 直接通信：

进程通信可划分为阻塞或非阻塞：

- 阻塞通信
  - 阻塞发送：发送者在发送消息后进入等待，直到接收者成功收到。
  - 阻塞接收：接收者在请求接收消息后进入等待，直到成功收到一个消息。
- 非阻塞通信
  - 非阻塞发送：发送者在消息发送后，可立即进行其他操作。
  - 非阻塞接收：没有消息发送时，接收者在请求接收消息后，接收不到任何消息。

进程发送的消息在链路上可能有 3 种缓冲方式：

- 0 容量：发送方必须等待接收方
- 有限容量：通信链路缓冲队列满时，发送方必须等待
- 无限容量：发送方不需要等待

进程间通信的 4 种方法：

- **信号**（Signal）：进程间的软件中断通知和处理机制。如：`Ctrl + c`
- **管道**（Pipe）：进程间基于**内存文件**的通信机制。如：`ls | more`。
- **消息队列**（Message Queues）：由操作系统维护的以字节序列为基本单位的间接通信机制。
- **共享内存**：把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制。

## 实验

实现锁机制、信号量机制。
